@startuml


/'Esto de aqu√≠ ignoren'/
skinparam Linetype ortho
skinparam class {
BackgroundColor LightBlue
ArrowColor Black
BorderColor Black
}

package business {
    class GameLogic {
        -player: Player
        -level: Level
        -isRunning: boolean
        -numLevel: int
        -collisionChecker: CollisionChecker
        +movePlayer(direction: Direction): void
        +playerPowerUps(): void
        -isCollidingWithAnEnemy(): boolean
        -isCollidingWithABlock(direction: Direction): boolean
        -isCollidingWithAFruit(): boolean
        +isRunning(): boolean
        +run(direction: Direction): void
    }

    class Level {
        -map: Map
        -enemies: ArrayList<Enemy>
        -fruits: ArrayList<ArrayList<Fruit>>
        -runningFruitLayer: int
        -troll1: Enemy
        +getPlayerInitialPosition(): Position
        +getMap(): Map
        -getFruit(position: Position, int runningFruitLayer): Fruit
        -getFruitLayer(int runningFruitLayer): ArrayList<Fruit>
        +decreaseFruitCounter(position: Position): void
        -fruitLayerIsEmpty(int runningFruitLayer): boolean
        +fruitsEqualZero(): boolean
        +isCollidingWithAnEnemy(position: Position): boolean
        +isCollidingWithAFruit(playerPosition: Position): boolean
    }

    class Map {
    /'no se pone final'/
        -mapSizeX: int
        -mapSizeY: int
        -blocks: Block[][]
        -blockManager: BlockManager
        +getBlock(position: Position): Block
        +frontBlockIsIce(direction: Direction, position: Position): boolean
        +setIce( (position: Position): void
        +setBlock(position: Position, int block): void
        -loadBlock(numbers: Vector<Vector<Integer>): Block[][]
        +getMapSizeX(): int
        +getMapSizeY(): int
        +isBlockSolid(frontPosition: Position): boolean
    }

    class Block {
        -name: String
        -SOLID: boolean
        +isSolid(): boolean
    }

    class Ice {
        -breakable: boolean
    }

    class Fruit {
        -name: String
        +setPosition(position: Position): void
        +getName(): String
    }

    class Position {
        -x: int
        -y: int
        +getX(): int
        +getY(): int
        +getFrontPosition(direction: Direction): Position
        +setX(int x): void
        +setY(int y): void
        +equals(p2: Position): boolean
    }

    enum Direction {
        UP
        DOWN
        RIGHT
        LEFT
        SPACE
    }

    package managers{
        class BlockManager{
            -blocks: HashMap<Integer, Block>
            +getBlock(int blockNumber): Block
        }

        class CollisionChecker{
            -map: Map
            +trappedBetweenBlocks(position: Position): boolean
            +frontBlockIsSolid(direction: Direction, position: Position): boolean
        }

        class FruitManager{
            -fruits: HashMap<Integer,Fruit>
            +getFruit(int fruitNumber): Fruit
        }

        class LevelManager{
            -{static}levels: HashMap<Integer, Level>
            +{static}getLevel(int level): Level
        }
    }

    package interfaces{
        interface Movable{
            +{abstract} move(direction: Direction): void
        }
        interface PowerUps{
            +breakIce(map: Map): void
            +putIce(map: Map): void
            +powerUpIce(map: Map): void
        }
    }

    package characters {

        abstract class Entity {
            #position: Position
            #direction: Direction
            #{static}advance: int
            +getPosition(): Position
            +getDirection(): Direction
        }

        class Player {
            -POSIBLE_SPEED: int = 1
            -alive: boolean
            +changeDirection(directionExpect: Direction): void
            +move(direction: Direction): void
            +die(): void
            +powerUpIce(map: Map): void
            +breakIce(map: Map): void
            +putIce(map: Map): void
        }

        abstract class Enemy{
            #collisionChecker: CollisionChecker
            +setPosition(positionExpect: Position): void
            +setDirection(direction: Direction): void
            +setCollisionChecker(collisionChecker: CollisionChecker): void
        }

        class Troll{
            +run(): void
            +move(direction: Direction): void
        }

        class BlueCow {
            -potionToFollow: Position
            -run(): void /'es runnable'/
            -follow(position: Position): void
            +move(direction: Direction): void
            +passPositionToFollow(position: Position): void
        }
    }
}

package data{
    class DataManager {
        +{static}loadMap(String path): Map
        +{static}loadFruitLayer(String path): ArrayList<Fruit>
        +loadFruits(String[] fruitPaths): ArrayList<ArrayList<Fruit>
        -{static}readTxtFile(String path): void
        -{static}strVectorToIntVector(Vector<String> readLines): Vector<Vector<Integer
        +{static}writeFile(archivo: File, object: Object): void
        +{static}readFile(archivo: File): Object
    }
}

Player ... Level
Player ...> Map
Enemy  .l.> Map

GameLogic --> Level
GameLogic -> Player

Level --> Map
Level --> Enemy
Level --> Fruit


Map --> Block
Map --- DataManager

Entity <|-- Player
Entity <|-- Enemy
Enemy <|-- Troll

Movable <|.. Enemy
Movable <|.. Player
PowerUps <|.. Player
Movable <|.. Troll

@enduml